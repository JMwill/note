# 状态模式

关键：区分事物内部的状态，事物内部状态的改变往往会带来事物的行为改变

一般的封装是优先封装对象的行为，但是状态模式中是对象的状态进行封装，将事物的每一种状态都封装成单独的类，跟某种状态有关联的类都封装在这个类的内部，同时，还可以将状态的切换规则事先分布在状态类中，能够有效消除原本存在的大量分支语句。

***

状态模式在GoF中的定义：允许一个对象在其内部状态改变的时改变它的行为，对象看起来似乎修改了它的类。

以逗号分割，前半句意思：将状态封装成独立的类，并将请求委托给当前的状态对象，当对象的内部状态改变时，会带来不同的行为变化。

后半句：从客户的角度看，使用的对象在不同的状态下具有截然不同的行为，这个对象看起来是从不同的类中实例化而来的，实际上是使用了委托的效果

***

优点：
- 定义了状态与行为之间的关系，并封装在一个类里面，通过新增状态类，从而方便地增加新的状态和转换
- 避免Context无限膨胀，状态切换的逻辑被分布在状态类中，去掉Context中原本过多的分支条件
- 用对象代替字符串来记录当前状态，使得状态的切换一目了然
- Context中的请求动作和状态类中封装的行为可以非常容易地独立变化而不互相影响

缺点：
- 需要定义很多的状态类
- 系统会增加许多对象
- 逻辑分散在状态类中

***

性能优化点：
- 当状态对象过多且并不会频繁切换时，只需要在用到的时候才创建相关的状态对象
- 当状态对象不多，且需要频繁切换时，可以一开始就创建好对象，且无需销毁对象
- 通过享元模式共享state对象

***

状态模式与策略模式的异同

同：
- 状态模式与策略模式都封装了一系列的算法或者行为
- 都有一个上下文，一些策略或者状态类
- 上下文把请求委托给相应的类来处理

异：
- 策略模式中的各个类之间是平等有平行的，各个类之间没有任何联系，使用者需要熟悉策略类
- 状态模式中，状态与状态对应的行为是早已经被封装好的，状态之间的切换也早被规定完成，‘改变行为’这件事情发生在状态模式的内部，无需使用者了解
