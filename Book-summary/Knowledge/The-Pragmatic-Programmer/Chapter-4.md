# 巜程序员修练之道》

## 注重实效的偏执

### 按合约设计

合约规定了既规定了自己的权利与责任，也规定了对方的权利与责任。同时，还写明了任何一方没有遵守合约的后果的约定。我们可以采用这种理念来帮助软件模块进行交互。

#### DBC

**按合约设计的概念**，是一种简单强大的技术，它关心的是用文档记载(并约定)软件模块的权利与责任，以确保程序正确性。

按合约设计的核心所在是：用文档记载程序声明要做的事情，并进行校验。

系统中的例程通过函数或者方法做某种事情，在做之前对世界的状态可能会有某种期望，并且也可能有能力陈述系统结束时的状态。这些期望与状态被这样描述：
- 前条件。为了调用例程，必须为真的条件。在前条件被违反时，例程决不应被调用传递好的数据是调用者的责任
* 后条件。例程保证会做的事，例程完成时世界的状态。
* 类不变项。类确保从调用者的视角来看，该条件总是为真。内部处理过程则不一定保持，但是在例程退出、控制返回到调用者时，不变项必须为真

例程与任何潜在的调用者之间的合约可以解读为：

如果调用者满足了例程的所有前条件，例程应该保证其完成时、所有后条件和不变项将为真。

按合约设计的强调的重点在于"懒惰"，意思是：在开始之前接受的东西要严格，而允诺返回的东西要尽可能少。

继承和多态是面向对象语言的基石，也是合约可以真正闪耀的领域。为此当使用继承来创建一个"is-a"的关系的时候，我们要明白一个原则，替换原则：子类必须要能够通过基类的接口使用，而使用者无须知道其区别。

有内建的DBC支持的语言自动在编译器和runtime系统中检查前条件和后条件。这种情况下我们可以获得最大的好处，因为所有的代码库、函数库都必须要遵守它们的合约。如：Eiffel和Sather语言。而对于没有内建支持的语言泽可以通过预处理器以及特殊形式的注释来实现合约。

#### DBC与早崩溃

DBC相当符合我们关于早崩溃的概念。通过检查前条件来使程序早崩溃，能够更容易在问题现场找到和诊断问题。

对于没有内建DBC的语言，负责检查前条件的是调用者，因为前条件是在调用者调用例程之后，进入例程自身之前，在幕后测试的。在对参数进行任何显式的检查都必须由调用者来完成，例程自身永远都不会看到违反了前条件的参数。

#### 不变项的其他用法

- **循环不变项**。在复杂的循环上正确地设定边界条件很可能会很成问题，在这种情况下，不变项可以有帮助：循环不变项是对循环的最终目标的陈述，而又进行了一般化，在循环执行前和每次循环迭代时，它都是有效的。可以将其作为一种微型合约。
* **语意不变项**。使用语意不变项可以表达不可违反的需求，一种"哲学合约"。一定不要固定的需求、不可违反的法则与政策混为一谈，后者会随着新的管理制度的出台而改变，这就是为什么要使用术语："语意不变项"的原因，它是食物的确切含义的中心，而不受反复无常的政策的支配

#### 动态合约与代理
在自治代理的领域中，合约并不一定是固定的、不可改变的规范。按照"自治"的定义，代理有拒绝不想接受的请求的自由。

任何依赖于代理技术的系统对合约协商的依赖都是至关重要的。即使它们是动态生成的。

通过足够的"能够相互磋商合约，以实现某个目标"的组件和代理，也许可以解决生产率的危机，让软件为我们解决它。

### 死程序不说谎

任何错误都能够提供信息，注重实效的程序员都知道不能忽略任何错误。

**要崩溃，不要破坏**，尽早检测问题的好处之一是可以更早崩溃。多数时候，让程序崩溃是最佳选择。有时候，简单地退出运行中的程序并不合适，但基本原则是一样的——当代码发现某件被认为不可能发生的事情已经发生时，程序后续的任何行为都变的不可信任，需要尽快终止。死程序带来的危害比有问题的程序要小得多。

### 断言式编程

**如果一件事不可能发生，那么用断言来确保它不会发生**，无论何时当发现自己在思考"但那当然不可能发生"时，增加代码检验它。最简单的办法是使用断言。

需要记住的是：
1. 断言不应该有副作用
2. 因为断言可能会被关闭，因此不要把必须执行的代码放在断言中
3. 不要用断言代替真正的错误处理，断言检查的是决不应该发生的事情

#### 让断言开着

程序的第一条防线是：检查任何可能的错误，第二条防线是使用断言设法检查疏漏的错误。

即使在交付程序时依然开启断言会对性能有影响，但为了增加安全性，最好还是保持断言的开启，只关闭那些对性能有很大影响的断言。

### 何时使用异常

检查每一个可能的错误是一种良好的实践。但是，实践中这样做可能把代码引向丑陋，程序的正常逻辑会被错误处理的分支完全遮蔽，这个时候，使用异常将错误处理移动到一处，能够使正常的控制流变得清晰，且代码更为简洁。

#### 什么是异常情况

异常很少作为程序的正常流程的一部分使用；异常应保留给意外事件。如果移走异常处理器代码无法正常运行，那么异常也许正用在非异常的情形中。

如果某个事物应该存在，但是由于意外的事情发生了而导致应该存在的事物不见了，这个时候就适合使用异常。但是如果原本就不清楚事物是否应该存在，那这就不是异常情况，应该返回错误。

**将异常用于异常的问题**

#### 错误处理器是另一种选择

错误处理器是检测到错误时调用的例程。通过注册一个处理特定范畴的错误的例程，处理器会在相应错误发生时被调用。

### 怎样配平资源

多数时候，资源使用遵循一种可预测的模式：分配资源、使用它，解除资源分配。所以对于资源我们要做到**有始有终**。打开(分配)资源跟关闭(释放)资源应该在同一个地方(函数体内)进行。

对于一次需要不止一个资源的例程时，可以拓展资源分配的基本模式。这里有两个建议：

1. 解除资源分配时的顺序与分配资源时的次序相反。这样做可以避免一个资源含有对另一个资源的引用时被解除分配而造成的资源泄露。
2. 在代码的不同地方分配同一组资源时，总是以相同的次序分配它们。这样做可以降低发生死锁的可能性。

#### 对象与异常

分配与解除分配的组合跟构造器与析构器的组合十分类似。

#### 配平与异常

支持异常的语言可能会使解除资源的分配变得棘手。保证在发生异常之前分配的所有资源都得到清理的答案在一定程度上取决于语言。

#### 当无法配平资源时

有时基本的资源分配模式并不适用。这种情况通常会出现在使用动态数据结构的程序中。一个例程分配一块内存，并把它链接进某个更大的数据结构中，且内存可能会存留一段时间。

这里的诀窍是为内存分配设立一个语意不变项，决定谁为某个聚集数据结构中的数据负责。当解除顶层结构的分配时会发生什么。这里有三个主要选择

1. 顶层结构还负责释放它包含的任何子结构。这些结构随即递归地删除它们包含的数据等等。
2. 只是解除顶层结构的分配。只想的(没有在别处饮用的)任何结构都会被遗弃。
3. 如果顶层结构含有任何子结构，它就拒绝解除自身的分配。

这里的选择取决于每个数据结构自身的情形。但对于每个结构，都必须明确做出选择，并始终如一地实现所做的选择。

#### 检查配平

构建代码，对资源确实得到了适当的释放进行实际检查是一个好的做法。
 