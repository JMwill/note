# 巜程序员修练之道》

## 第七章 在项目开始之前

### 需求之坑

**完美，不是在没有什么要增加，而是在没有什么需要去掉时达到的。**

**不要搜集需求——挖掘它们**

#### 挖掘需求

需求是对需要完成的某件事情的陈述。但是需求应该是一般陈述，而不要夹杂着政策信息等东西。通过这样的方式搜集需求能够很自然地去开发为支持元数据而进行良好分解的系统。

在讨论用户界面时，需求、政策和实现之间的区别可能会变得非常模糊。如果用户一定要有某种事物，那么这就是需求。相反，用户需要的就是某种事物的相应能力，并用这个事物来表示而已。

找出用户为何要做特定事情的原因、而不只是做这件事情的方式很重要。开发到最后必须要解决用户的商业问题，而不只是满足他们陈述的需求。用文档记载需求背后的原因将在每天进行实现决策时给团队带来无价的信息。

其中一种深入了解用户需求、却未得到足够利用的技术：成为用户。通过跟有经验的用户一起工作、沟通，能够帮助与用户建立信任和沟通的基础。**与用户一同工作，以像用户一样思考**

开采需求的过程是开始与用户群建立和谐的关系、了解他们对正在构建的系统的期许和希望的时机。

#### 建立需求文档

捕捉用户需求的用例概念，会让你描述系统的特定用法，以一种更为抽象的方式，而不是根据用户界面。

看待用例的一种方式是强调其目标驱动的本质。

把形式化的模版用作备忘录，可以确保自己包括了用例中所需的所有信息：履行指标、其它有关方面、优先级、频度、以及各种可能出现的错误和异常（"非功能需求"）。模版还可以充当和用户会谈用的现成议事安排。

#### 用例图

用UML活动图捕捉工作流，使用概念层类图为手边的事务建模都很有用。而真正的用例是具有层次结构和交叉链接的文字描述。用例可以含有指向指向其它用例的超链接，也可以互相嵌套。

不要做任何表示方法的奴隶，只要是与用户交流需求的最好的方法，都可以加以利用。

#### 规定过度

制作需求文档时的一大危险是太过具体。需求文档需要保持抽象，在涉及到需求的地方，最简单的、能够准确反映商业需求的陈述是最好的。但是必须把底层的语义不变项当作需求进行捕捉，并把具体的或当面的工作实践当做政策记入文档，而不是含糊不清地进行记录。

#### 看远些

**抽象比细节活得更长久**

看远些意味着需要生成准确，且足够抽象的陈述。

- - - -

许多项目的失败都归咎于项目范围的增大——也称为特性膨胀、蔓延特性论、或是需求蔓延。

管理需求增长的关键是向项目出资人指出每项新特性对项目进度的影响。在进度延后并被责难时，可以有助于准确、完整地了解需求增长时怎样以及何时发生的。

#### 维护词汇表

一旦开始讨论需求，用户和领域专家会使用对他们有特定含义的术语。因此需要创建并维护项目词汇表——定义项目中使用的专业术语和词汇的地方。项目的所有参与者，都应该使用这个词汇表以确保一致性。

**使用项目词汇表**

如果用户与开发者用不同名称指称同一事物，或者更糟，使用同一名称指称不同事物的话，项目很难会成功。

#### 把话说出来

将需求制作成超文本文档，可以更好地满足不同听众的需要。同时能够避免需求过时。

### 解开不可能解开的谜题

解开谜题的秘诀是确定真正的（而不是想象的）约束，并在其中找出解决办法。有些约束是绝对的；有些则是先入之见。绝对的约束必须受到尊重，不管看上去有多愚蠢或讨厌。

#### 自由度

解开谜题的关键在于确定附加给你的各种约束，并确定你确实拥有的自由度，因为在其中将会找到解决方案。我们需要挑战任何先入之见，并评估它们是否是真实的、必须遵守的约束。

问题不在于是在盒子里面思考，还是在盒子外面思考，而是在于找到盒子（各种约束和条件的边界）——确定真正的约束。

**不要在盒子外面思考——要找到盒子**

面对棘手的问题时，列出所有可能的途径。不管有多无用或愚蠢（正门潜入敌方：特洛伊木马）都不要排除任何东西。检查每一项并解释为何不能采用某个特定的途径。并证明。

对各种约束进行分类，并划定优先级。先确定最为严格的约束，然后再在其中考虑其余的约束。

#### 一定有更容易的方法

当发现处理的问题似乎比预想的要难得多。或者认为特定问题是"不可能解决"时，可以通过以下问题对需求重新诠释。

- 有更容易的方法吗？
* 这是在设法解决真正的问题，还是被外围的技术问题转移了注意力？
* 这件事为什么是一个问题？
* 是什么使它如此难以解决？
* 它必须以这种方式完成？
* 它真的必须完成？

我们需要的是真正的约束、令人误解的约束、以及区分两者的智慧。

### 等你准备好

**有时犹豫的人会得以保存**

当头脑里反复出现某种疑虑，要注意它。**倾听反复出现的疑虑——等你准备好再开始**

当面对一项任务时，如果反复感觉到疑虑或是体验到某种勉强，但是无法准确指出问题所在，这时需要时间，让疑虑结晶成某种更坚实的东西，某种可以处理的东西。让我们的直觉为表演做出贡献。

#### 是良好的判断，还是拖延

构建原型。选择一个觉得会有困难的地方，开始某种"概念验证"。随后会出现两种情况：

1. 开始后不久，就会厌烦，并明白最初的勉强只是因为拖延。这时可以放弃原型回到开发中。
2. 随着原型取得进展，某个时刻会意识到有些基本前提错了。并清楚看到如何纠正错误。这时可以放弃原型并投入正常的项目。

当做出决定，把构建原型当做调查自己的不适的一种方法时，要记住为何这样做。

### 规范陷阱

编写程序规范就是把需求归约到程序员能够接管的程度的过程。旨在解释并澄清系统的需求，比如消除主要的歧义。规范也是与用户的约定——对他们的需要的汇编，也是一份隐含的合约：最终系统将会符合该合约的要求。

**对有些事情"做"胜于"描述"**

规定过细的没有留下任何解释余地的设计的约束会剥夺编码者发挥技巧和艺术才能的权利。

需求搜集、设计、以及实现应该视为同一过程——交付高质量的系统——的不同方面。规范和实现不过是同一过程——设法捕捉和编撰需求——的不同方面。健康的开发过程鼓励把来自实现与测试的意见反馈到规范中。

### 圆圈和箭头

**不要做形式方法的奴隶**

形式方法的缺点：

* 大多数形式方法结合图和某些说明文字来捕捉需求。但是由于每一样都是以设计者的解释为基础的，就会使得其像书面需求一样。最好还是向用户展示原型，并让他实际使用。
* 形式方法似乎鼓励专门化，有某组人构建特定的方面，这会造成糟糕的交流和工作浪费。我们需要了解正在开发的整个系统，不一定要深入，但是需要知道组件如何交互，数据存放点，还有需求。
* 形式化方法未能阐释系统应该展现的动态性。它会鼓励我们在对象间建立静态关系，而其实对象本应该动态编织在一起的。我们编写程序时喜欢有适应能力的动态系统，并使用元数据让我们能在运行时改变应用的特征。

#### 是否应该使用形式方法

应该，但是需要记住形式方法的使用应该在仔细分析后觉得需要的情况下才使用，不要做方法学的奴隶。

批判地看待方法学，从各种方法学中提取精华，融合成一套好的工作习惯。不断努力提炼和改善开发过程。不要把方法学呆板的限制当做世界的边界。

**昂贵的工具不一定就能制作出更好的设计**
