#+TITLE: 计算机程序的构造和解释 (SICP)

* TODO 第一章: 构造过程抽象

心智活动的三个主要表现:

1) 将若干个简单认识组合成一个复杂的认识, 由此产生各种复杂的认识
2) 将两个认识放在一起对照, 不管它们如何简单或复杂, 这里并不用将它们合而为一. 通过这样的方式得到有关它们相互关系的认识
3) 将有关认识与实际中同等存在的认识隔离开, 就称为抽象, 所有具有普遍性的认识都是这样得到的

对应到语言上, 其也需要提供三种机制:

1) *基本表达形式*, 用于表示语言所关心的最简单的个体;
2) *组合的方法*, 通过它们可以从较简单的东西出发构造出复合的元素;
3) *抽象的方法*, 通过它们可以为符合对象命名, 并将它们当作单元去操作;


绝对值的实现
#+begin_src scheme :tangle abs.scm
(define (abs x)
  (cond ((< x 0) (- x))
        (else x)))

(define (abs x)
  (if (< x 0)
       (- x)
       x))
#+end_src

实现平方函数
#+begin_src scheme :tangle square.scm
(define (square x)
  (* x x))
#+end_src

实现平均值计算函数
#+begin_src scheme :tangle average.scm
(define (average x y)
  (/ (+ x y) 2))
#+end_src

在 lisp 的解析器中, 有分应用序以及正则序, 两个过程简单地说就是先将传入参数求值后代入过程, 还是先将过程展开平铺后从内过程到外过程不断归约.

一般的解释器都使用应用序, 而我当前知识量上能够感知的问题就是正则序会导致多个过程重复计算的问题. 比如:

#+begin_src scheme
(define (p) (p))

(define (test x y)
  (if (= x 0)
      0
      y))
#+end_src

上述的程序在使用 "应用序" 时, 因为先计算参数 x 与 y, 因此过程会陷入 p 的不断递归, 而如果解析器存在尾递归优化, 则 test 将会无限执行. 如果是 "正则序" 则过程展开后, 从内部过程先执行, if 作为一个特殊过程, 将只执行返回 0 的操作, y 将不会被执行.

需要说明一下的是 if 这个特殊过程有其存在的意义, 想一下如果 if 不是在先行条件为 False 的情况下才执行 else 的话会出现什么问题?

#+begin_src scheme :tangle new-if.scm
(define (new-if predicate then-clause else-clause)
  (cond (predicate then-clause)
        (else-clause)))

(new-if (= 2 3) 0 5)
(new-if (= 1 1) 0 5)
#+end_src

上述的 new-if 能够执行一般的任务, 但是对于一些特殊的任务则会陷入困难:

#+begin_src scheme :tangle sqrt.scm
(load "average.scm")
(load "abs.scm")
(load "new-if.scm")
(load "square.scm")

(define (improve guess x)
  (average guess (/ x guess)))

(define (good-enough? guess x)
  (< (abs (- (square guess) x)) 0.001))

(define (sqrt-iter guess x)
  ;; (new-if (good-enough? guess x)
  (if (good-enough? guess x)
      guess
      (sqrt-iter (improve guess x)
                 x)))
(define (sqrt x)
  (sqrt-iter 1.0 x))

;; 如果使用 new-if 这里将会无限执行
(sqrt-iter 9)
#+end_src

上述的 sqrt-iter 将会无限执行直到栈溢出, 因为 new-if 只是一个普通过程, 因此根据应用序解释的逻辑, 传入的参数执行计算后就会陷入循环.


对于 good-enough? 的实现, 过于小或者大的数都无法正确执行, 因为原实现上, 过小的数简单相减就会达到要求退出求解, 过大的数会由于精度的原因出现死循环. 即 improve 每次得到的值都很大, 从而 =(- (square guess) x)= 一直是个大数

#+begin_src scheme :tangle p16-1-7.scm
(load "sqrt.scm")

(define (good-enough? new-guess old-guess)
  (> 0.0001
     (/ (abs (- new-guess old-guess))
        old-guess)))

(sqrt 9)
#+end_src

通过将新旧值相减并求比值, 当比值小于某个阈值时停止, 这种方式能够避免大数进行平方时的问题以及小数之间的精度丢失问题.


求解立方根实现
#+begin_src scheme :tangle p17-1-8.scm
(define (improve guess x)
  (/ (+
       (/ x (square guess))
       (* 2 guess))
     3))

(define (good-enough? guess x)
  (< (abs (- (cube guess) x))
     0.0001))

(define (cuberoot-iter guess x)
  (if (good-enough? guess x)
      guess
      (cuberoot-iter (improve guess x) x)))

(define (cuberoot x)
  (cuberoot-iter 1.0 x))

(cuberoot 8)
#+end_src

** 过程与产生的计算

了解过程的执行, 有利于认识不同过程起到的影响. 以阶乘函数为例来了解 "线性递归过程" 与 "线性迭代过程" 之间的差异

#+begin_src scheme :tangle factorial.scm
;; 本实现是按照阶乘的定义: n! = n * (n - 1)! 来实现
;; 最终效果就是:
;; (factorial 6)
;; (* 6 (factorial 5))
;; (* 6 (* 5 (factorial 4)))
;; ...
(define (factorial n)
  (if (= n 1)
      1
      (* n (factorial (- n 1)))))

;; 这一实现是基于 n! = 1 * 2 ... * (n - 1) * n
;; 最终效果是:
;; (factorial 6)
;; (factorial 1 1 6)
;; (factorial 1 2 6)
;; (factorial 2 3 6)
;; ...
(define (factorial n)
  (fact-iter 1 1 n))

(define (fact-iter product counter max-count)
  (if (> counter max-count)
      product
      (fact-iter (* product counter)
                 (+ counter 1)
                 max-count)))
#+end_src

上述的阶乘实现都没有问题, 但是第一个实现具有线性依赖, 必须要等过程展开到最后一个位置返回 1 才能够逐步进行收敛直到最终得到结果; 这种随着计算过程进行, 构造起了一个推迟执行的链条, 其链条长度随着 n 值线性增长, 则这样的过程称之为 /*线性递归过程*/;

而第二个实现, 并不依赖前后过程, 即使运算过程中断了, 只需要存储好 product, counter, max-counter 的信息就可以立即恢复原计算过程; 这种过程称之为 /*线性迭代过程*/; 一般线性迭代过程其 *状态* 可以用固定数目的 *状态变量* 描述, 同时存在一套固定的规则, 描述了计算过程从一个状态到下一状态转换时, 变量的更新方式, 以及可能有的: 结束检测, 用于终止计算过程; 因其所需计算步骤随着 n 增长所以才叫 线性迭代过程;

区分两者的最明显标志是: 线性迭代过程具有 程序变量 来提供计算状态的完整描述, 而线性递归过程只具有描述计算过程在何处的信息, 而无状态的描述.

这里需要区分好递归与递归的计算过程, 前者表示程序调用自身, 后者表示计算的过程其进展的方式是递归的, 一层套一层, 而迭代的计算过程则是根据状态描述进行步进, 不形成依赖

*** 斐波那契数列的迭代实现

#+begin_src scheme :tangle fib.scm
(define (fib n)
  (fib-iter 1 0 n))

(define (fib-iter a b count)
  (if (= count 0)
      b
      (fib-iter (+ a b) a (- count 1))))

(fib 1000)
#+end_src

线性迭代形式的斐波那契数列计算量级下降巨大, 但是不代表递归形式一无所长. 递归更加直截了当, 在对层次结构性的数据进行操作时更自然, 强大.

递归算法的实现需要满足的条件一定是能够将大问题进行 "归约", 从而将大问题在每一次递归中变成更小的问题, 最终满足跳出条件, 从而结束整个过程.

以兑换硬币为例子, 假设从大到小有四种类型的硬币, 则在兑换金额为 a 的金额时有多少种组成方式.

从描述中可以得到的信息是总金额为 a, 换成 n 种硬币的不同方式有几种. 则问题可细分为:

- 现金数 a 兑换除第一种硬币外的所有其他硬币的方式的数目.
- 现金数 a - d 兑换成所有种类的硬币的不同方式的数目, d 表示上一条提到的第一种硬币的币值.

以上两个数目相加则能够得出结果.

从上面的描述可以看出, 第一个条件将硬币的种类缩减了, 第二个条件将金额缩小了. 两个条件最终会缩减到如下的结果:

- a 为 0 算作 1 种换零钱的方法
- a 小于 0 算作 0 种换零钱的方法
- n 为 0 算作 0 种换零钱的方法

上述的三个条件则是跳出的最终结果. 翻译成代码则为:

#+begin_src scheme :tangle count-change.scm
(define (count-change amount)
  (cc amount 5))

(define (cc amount kinds-of-coins)
  (cond ((= amount 0) 1)
        ((or (< amount 0) (= kinds-of-coins 0)) 0)
        (else (+ (cc amount
                     (- kinds-of-coins 1))
                 (cc (- amount
                        (first-denomination kinds-of-coins))
                     kinds-of-coins)))))

(define (first-denomination kinds-of-coins)
  (cond ((= kinds-of-coins 1) 1)
        ((= kinds-of-coins 2) 5)
        ((= kinds-of-coins 3) 10)
        ((= kinds-of-coins 4) 25)
        ((= kinds-of-coins 5) 50)))
#+end_src


*** 练习题 1.11

#+begin_src scheme :tangle p27-1-11.scm
;; 两者的速度差距是巨大的
;; 基本上，如果 n > 20 就能明显感觉到速度上的差异
(define (f n)
  (if (< n 3)
      n
      (+ (f (- n 1)) (* (f (- n 2)) 2) (* (f (- n 3)) 3))))

(f 30) 

(define (f2 n)
  (cond ((= n 1) 1)
        ((= n 2) 2)
        (else (f2-iter 0 1 2 2 n))))

(define (f2-iter va vb vc counter max-counter)
  (if (= counter max-counter)
      vc
      (f2-iter vb vc (+ vc (* vb 2) (* va 3)) (+ counter 1) max-counter)))

(f2 30)
#+end_src