# Python对象

Python class中的 `__new__` 函数是构造函数, 只接收一个参数, 这个参数是将要被构造的类本身, 在对象被构造之前调用, 并返回刚创建的对象. 而 `__init__` 则是初始化函数, 用于初始化实例的各项数据.

## 引用包

python中引用包可以采用绝对导入与相对导入的方式, 绝对导入直接使用包名称来进行一层层的导入, 而相对导入则是基于**当前模块**来进行导入的. 所以, 如果直接执行某个模块里面的文件, 则这个文件本身不能包含 `..`, 否则就会报错, 显示无法导入对应的包.

## 创建模块级别的变量

有一些场景是需要创建一个模块级别的变量的, 比如数据库连接实例, 在需要这些模块级别的变量的时候, 一开始就导入有可能会导致一些问题, 比如连接创建需要耗时, 会减缓程序启动, 或者说连接创建失败等.

```py
# Database module
class Database:
    # 数据库实现
    pass

database = Database()
```

上面的实例就会有这样的问题, 通过对全局变量赋值, 可以实现模块级别变量的后导入

```py
class Database:
    # 数据库实现
    pass

database = None

def initialize_database():
    global database
    database = Database()
```

python中的变量都是公开的, 对于一般不想别人访问的变量可以使用 `_` 单下划线来表示, 而对于强烈不想被访问的可以用 `__` 双下划线来表示, 其中, 用双下划线表示的变量在Python解析器解析时, 外部获取需要以这种 `_modulename__property` 方式才能获取到.

## `__init__.py`的作用

具有 `__init__.py` 的文件夹会被认为是python的一个包. 这个文件里可以包含任意变量或者类声明, 这些声明会作为包的一部分被使用. 如有一个包名为: `package_1`, 在这个包里面有模块 `a` 具有功能 `b` 则可以在 `__init__.py` 里面加入下面的一句: `from .a import b`, 那么在使用包 `package_1` 则可以 `from package_1 import b` 这样子来使用.