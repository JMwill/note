## 第五章：内存控制

### 垃圾回收与内存限制

1. 内存限制
由于Nodejs是基于V8引擎实现的后端语言，在内存使用上，由V8进行分配的内存在普通情况下64位系统最多只能使用。14G左右的内存，想要可使用的量变得大一些，可以通过运行Nodejs前用参数进行定义：`node --max-old-space-size=1700 run.js // 单位是MB 或者 node --max-new-space-size=1024 run.js 单位KB`，使用这种方式运行，能够突破V8的内存限制，但是想要对1.5GB的垃圾进行回收时会导致应用性能以及相应能力直线下降。

2. 垃圾回收机制
Nodejs的垃圾回收主要基于分代式机制，将对象按照生存周期长短分为新生代与老生代，新生代为存活时间较短的对象，老生代则为存活时间较长或者常驻内存的对象。对于新生代对象，使用通过空间换时间的Scavenge算法，将堆内存一分为二，分别为From空间和To空间初始分配对象集中在From空间中，进行一次垃圾回收时由From空间复制到To空间，并对已经经历过一次回收或者To空间内存占比超过25%后的对象移动到老生代空间中，然后From空间与To空间角色互换。而对于老生代中的对象，由于存活数较多，使用标记清除的Mark-Sweep和Mark-Compact算法进行垃圾回收，其中Mark-Compact算法会在清除标记的同时对数据进行整理，以避免Mark-Sweep回收时造成内存空间过于破碎而导致提前触发垃圾回收。

V8进行垃圾回收的时候，需要将应用逻辑暂停下来，因此，在V8引擎将全停顿的垃圾回收改为增量标记，分段进行垃圾回收，使垃圾回收与应用逻辑交替运行，直到回收完成。

### 内存指标

通过使用`process.memoryUsage()`可以查看Node进程的内存占用情况。而Node中的内存并非全部由V8进行分配，这些非V8分配的内存成为堆外内存，如Buffer对象。

### 内存泄漏

造成内存泄漏的原因有：

* 缓存
* 队列消费不及时
* 作用于未释放

#### 使用内存当缓存

使用对象进行缓存需要进行缓存对象大小限定以及加上完善的过期策略防止内存无限制增长。

Node的模块机制在模块通过编译以后会缓存起来，因此模块是常驻在老生代里面，每个模块在编译执行后形成的作用域因为模块缓存的原因不会被释放。因此模块调用的局部变量不断占用内存的话会造成内存泄漏。

```
var leakArr = [];

exports.leak = function () {
    leakArr.push('leak' + Math.random());
}

当不可避免需要这么做时，需要提供清空队列的相应接口，用以释放内存
```

需要使用大量缓存时，使用进程外的缓存方案，如：Memcached或者Redis。能够（1）减少常驻内存对象的数量，提高垃圾回收效率（2）进程间共享缓存

#### 队列状态

一旦队列的消费速度低于生产速度就有可能会造成内存泄漏，这种类型的内存泄漏除了通过提高消费速度外，深度的解决方案应该是监控队列的长度，一旦出现堆积的情况，通过监控系统产生报警并通知，或者使用超时机制，在限定时间内没有完成响应时通过回调函数传递超时异常。使异步调用的回调具备可控响应时间，给消费速度一个下限值。

#### 内存泄漏排查

通过使用node-heapdump、node-memwatch等工具进行内存泄漏排查