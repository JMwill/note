# ================= Variable ================= #
[ $(uname -s | grep -c CYGWIN) -eq 1 ] && OS_NAME="CYGWIN" || OS_NAME=`uname -s`
export PATH=$PATH":$HOME/bin"
# ================= End Variable ================= #


# ================= Alias setting ================= #
alias vi=vim
alias em="emacs -nw"
alias ".."="cd .."
alias -- -="cd -"
alias ...="cd ../.."
alias ....="cd ../../.."
alias .....="cd ../../../.."
alias ......="cd ../../../../.."
alias _='sudo env PATH=$PATH'
alias tmux="tmux -2"

if hash python3 2>/dev/null; then
    alias python="python3"
    alias pserver="python3 -m http.server";
elif hash python2 2>/dev/null; then
    alias python="python2"
    alias pserver="python2 -m SimpleHTTPServer";
else
    echo "Can't not alias pserver"
fi
# ================= End Alias setting ================= #


# ================= Git setting ================= #
function gurl() {
    if [ -z "$1" ]; then
        echo "Usage: gurl commit-id"
        echo "get the full http url of commit"
    else
        local msg=`git remote -v|grep "origin\s\+.*\s\+(fetch)"|sed -e "s/origin\s\+\(.*\)\s\+(fetch)/\1/"`
        local url=""
      # github
        if [ "${msg:0:14}" == "git@github.com" ]; then
            echo https://github.com/`echo ${msg}|sed -e "s/^git\@github\.com\:\(.*\)\.git$/\1/"`/commit/$1
        fi
    fi
}
# pick commit id from `git log`
function gcid () {
    local commit_id=`git log --pretty=format:'%h %ad %s (%an)' --date=short|percol|sed -e"s/^\([a-z0-9]\+\)\s\+.*$/\1/"`
    echo ${commit_id}
}

#pick commit from `git log` and output its url
function gqurl () {
    local commit_id=`git log --pretty=format:'%h %ad %s (%an)' --date=short|percol|sed -e"s/^\([a-z0-9]\+\)\s\+.*$/\1/"`
    gurl ${commit_id}
}

# Enable tab completion
BASH_GIT_SETTING_PATH="$HOME/.bash_git_setting"
[ -f $BASH_GIT_SETTING_PATH/git-completion.bash ] && source $BASH_GIT_SETTING_PATH/git-completion.bash

# colors!
green="\[\033[0;32m\]"
blue="\[\033[0;34m\]"
purple="\[\033[0;35m\]"
reset="\[\033[0m\]"

# Change command prompt
[ -f $BASH_GIT_SETTING_PATH/git-prompt.sh ] && source $BASH_GIT_SETTING_PATH/git-prompt.sh
export GIT_PS1_SHOWDIRTYSTATE=1
# '\u' adds the name of the current user to the prompt
# '\$(__git_ps1)' adds git-related stuff
# '\W' adds the name of the current directory
export PS1="$purple\u$green\$(__git_ps1)$blue \W $ $reset"
# ================= End Git setting ================= #


# ================= Percol tool setting ================= #
function pclip() {
    if [ $OS_NAME == CYGWIN ]; then
        putclip $@;
    elif [ $OS_NAME == Darwin ]; then
        pbcopy $@;
    else
        if [ -x /usr/bin/xsel ]; then
            xsel -ib $@;
        else
            if [ -x /usr/bin/xclip ]; then
                xclip -selection c $@;
            else
                echo "Neither xsel or xclip is installed!"
            fi
        fi
    fi
}

# search the file and pop up dialog, then put the full path in clipboard
function baseff() {
    local fullpath=$*
    local filename=${fullpath##*/} # remove "/" from the beginning
    filename=${filename##*./} # remove  ".../" from the beginning
    # Only the filename without path is needed
    # filename should be reasonable
    local cli=`find . -not -iwholename '*/vendor/*' -not -iwholename '*/bower_components/*' -not -iwholename '*/node_modules/*' -not -iwholename '*/target/*' -not -iwholename '*.svn*' -not -iwholename '*.git*' -not -iwholename '*.sass-cache*' -not -iwholename '*.hg*' -type f -path '*'${filename}'*' -print | ~/.envs/python3/bin/percol`
    # convert relative path to full path
    echo $(cd $(dirname $cli); pwd)/$(basename $cli)
}

function ff() {
    local cli=`baseff $*`
    #echo ${cli} | sed 's%^'${HOME}'%~%'
    #echo -n ${cli}  | sed 's%^'${HOME}'%~%' | pclip
    echo ${cli}
    echo -n ${cli} | pclip
}

function cf() {
    local cli=`baseff $*`
    local p=`cygpath -w $cli`
    echo ${p}
    echo -n ${p} | pclip;
}
# ================= End Percol tool setting ================= #


# ================= Autojump setting ================= #
if [ $OS_NAME == Darwin ]; then
    [[ -s $(brew --prefix)/etc/profile.d/autojump.sh ]] && . $(brew --prefix)/etc/profile.d/autojump.sh || echo "You need to install *autojump* before run it!"
else
    [[ -s /usr/share/autojump/autojump.sh ]] && . /usr/share/autojump/autojump.sh || echo "You need to install *autojump* before run it!"
fi
# ================= End Autojump setting ================= #


# ================= End Virtualenv setting ================= #
if [ -x $(which python3) ]; then
    VIRTUALENVWRAPPER_PYTHON=$(which python3)
else
    VIRTUALENVWRAPPER_PYTHON=$(which python2)
fi

[ -d $HOME/.envs ] && export WORKON_HOME=$HOME/.envs || echo "Virtualenv storage folder does't exist" # 所有虚拟环境存储的目录
[ -s /usr/local/bin/virtualenvwrapper.sh ] && source /usr/local/bin/virtualenvwrapper.sh || echo "virtualenvwrapper.sh file can't launch"


[ -d $HOME/.envs/python2 ] || ([ -x "$(which python2)" ] && mkvirtualenv --python="$(which python2)" python2)
[ -d $HOME/.envs/python3 ] || ([ -x "$(which python3)" ] && mkvirtualenv --python="$(which python3)" python3)
# ================= End Virtualenv setting ================= #

