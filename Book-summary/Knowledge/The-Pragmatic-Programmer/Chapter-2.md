# 巜程序员修练之道》
## 第二章：注重实效的途径
### 重复的危害
程序员须从一开始就持续不断地维护应用，将其作为整个开发过程中的例行事务
由于在开发的规范、过程和程序中很容易重复表述知识，因此我们需要遵循**DRY**原则让系统中每一项知识具有单一、无歧义、权威的表示。让我们可靠地开发出更易于理解和维护的软件。

我们所遇到的重复大多可归为四类：
1. 强加的重复
2. 无意的重复
3. 无耐性的重复
4. 开发者之间的重复
#### 强加的重复
**同一信息的多种表示**，是常有的情况，这时，通过过滤器或代码生成器或预处理器等根据元数据实现自动的转换过程可以避免重复
**代码中的文档**，DRY法则告诉我们，低级的知识要放在代码中，真正的注释应该留给其他高级说明。否则就是在重复知识，对基础知识的注释意味着代码改变时也要修改注释。
**文档与代码**，代码的修改对应地也要对文档进行修订
**语言上的重复**，头文件、变量、库等引入时带来的重复。
#### 无意的重复
当设计时有可能一个类包含的数据在另一个类中也包含了，最后得到的对象会具有不规范的数据。是属于设计中的错误。
又如：
```java
class Line {
	public:
		Point start;
		Point end;
		double length
};
```
上面的代码中length其实是不必要的，因为可以根据两点来计算距离。
```java
class Line {
	public:
		Point start;
		Point end;
		double length() { return start.distanceTo(end); }
};
```
有时候由于性能等原因需要违反DRY原则时，需要做到影响局部化，将影响外界隔离开
```java
class Line {
	private:
		bool changed;
		double length;
		Point start;
		Point end;

	public:
		void setStart(Point p) { start = p; changed = true; }
		void setEnd(Point p) { end = p; changed = true; }

		Point setStart(void) { return start; }
		Point setEnd(void) { return end; }

		double getLength() {
			if (change) {
				length = start.distanceTo(end);
				changed = false;
			}
			return length;
		}
}
```
因此对于面向对象的语言，在可能的情况下应该总使用访问器读写对象的属性。在未来增加功能时会变得更容易。
#### 无耐性的重复
由于项目的时间压力，会促使我们走捷径--复制粘贴。但是，现在的捷径所带来的时间收益将来可能需要加倍奉还
#### 开发者之间的重复
最难检测的和最难处理的重复发生在项目的不同开发者之间。
在高层可以通过清晰的设计、强有力的技术项目领导，以及在设计中讲行得到了充分理解的责任划分，对问题加以处理。而在模块层则需要开发者之间主动支流将不能划入某个明显的责任区域的常用功能和数据进行复用的实现。
### 正交性
计算机中该术语用于表示某种不相依赖性或是解耦性。如果两个或更多事物中的一个发生变化，不会影响其他事物，那这些事物就是正交的。如一个设计良好的系统中，数据库与用户界面是正交的。
一个非正交系统的改变与控制都更加复杂，任何系统的各组件互相高度依赖的话，就无法在系统中进行局部修正了。
**设计组件**的时候要让组件自足：独立，具有单一、良好定义的目的即我们常说的内聚。这样，在组件外部接口不变的情况下，组件内部的任何改变都不会波及整个系统。同时能提高生产率降低风险。
**提高生产率**
* 与大块代码相比，编写多个相对较小，自足的组件更容易且也更容易进行设计与测试。使改动得以局部化
* 如果组件具有明确而具体的，良好定义的责任。正交能对组件复用起到促进作用
* 具有正交性的组件进行组合能有`M*N`的效果，而非正交的组件则只有`M*N-(M
N共同的部分`了
**降低风险**
* 正交的途径能够降低任何开发中的风险
* 模块之间分隔开了，从而出问题的区域也隔离在每个模块内。防止扩散到系统的其余部分
* 任何特定区域的改动与修正而导致的问题都将局限在该区域中，系统得以更健壮。
* 能更容易得到更好的测试
* 不会与特定的平台、产品等紧绑在一起。
**项目团队**中的工作分工也是一个正交性问题，只有每个人都知道要做什么才能避免互相妨碍，增加对责任的明确度。
管理团队时尽量把团队划分为责任得到了良好定义的小组，并使重叠降至最低。通过对可能变动区域的分析，可以对主要的基础设施组件划分，再将应用功能显而易见的部分进行划分。
团队正交性的非正式衡量可以通过改动对团队的影响来判断。
**设计**系统应该由一组相互协作的模块组成，每个模块都实现不依赖于其他模块的功能。有时会通过组织组件为多个层次，成为层级抽象。每层都只使用其下面的层次提供的抽象，降低模块间依赖关系失控的风险。
对于正交设计的测试，可以根据功能分析变动，每个功能的变动理论上仍然应该只影响一个模块。同时，**不要依赖无法控制的事物属性**
#### 编码
由于每次编写代码都有降低应用正交性的风险。因此可用以下技术维持正交性：
* 让你的代码保持解耦，即除非必要，不向其他模块暴露任何事情、实现不依赖其他模块的模块
* 避免使用全局数据，当代码引用全局数据时，都会将它与其他共享该数据的组件绑在一起
* 避免编写相似的函数，重复的代码会带来结构问题。
#### 测试
正交地设计和实现的系统更易于测试，因为系统组件间的交互是形式化的和有限的，更多的系统测试可以在单个的模块级进行
#### 文档
正交的文档，其坐标轴是内容和表现形式。真正正交的文档能显著地改变外观而不用改变内容。
#### 认同正交性
DRY原则是寻求使系统中的重复降至最小；正交性原则是降低系统各组件间相互依赖。紧密结合这两个原则，能使开发的系统更灵活。
### 可撤销性
可撤销性意味着对于系统的实现我们应使其灵活，有适应能力。避免进行过多的不可逆转的关键决策。因为越多的关键决策就越会提升改动的成本。**与开发软件的速度相比，需求、用户及硬件变得更快**
以接入数据库为例，将数据库的概念抽象出来--抽象到数据库只是把持久作为服务提供出来的程度，这样做能提供随时切换的灵活性。
**要记住不存在最终决策**
CORBA架构可以把项目的某些部分与开发语言或平台的变化隔离开来。
把第三方产品隐藏在定义良好的抽象接口后面，如果遇到必须大量把某些数据分散在整个代码中，则应该把需求放入元数据，并使用自动机制插入。
**灵活的架构**制作软件时让决策保持柔韧软和，避免糟糕的封装，高度耦合以及硬编码的逻辑或参数。
### 曳光弹
通过用曳光弹技术能得到及时的反馈。适用于新的项目，特别是构建从未构建过的东西时，使得在需求含糊不清，技术、算法、语言或库不熟悉等大量未知的情况下进行有效的开发，避免精力的多余投入。
之所以叫曳光弹是因为这种弹与真正的子弹在相同的环境下相同的约束下工作。能够对结果(能否击中/达到目标)得到即时反馈。
曳光代码包含任何一段产品代码都拥有的完整的错误检查、结构、文档、以及自查。只是功能不全。编写它是为了确定各组件间的连接，验证想法，确定目标。
曳光代码方法的优点:
* 能及早看到能工作的东西
* 构建了一个能在其中工作的结构
* 有了一个集成平台
* 有了可用于演示的东西
* 更能感觉到工作进展
曳光代码 VS 原型制作
使用原型是要探究最终系统的某些具体方面，而探究结束后则扔掉，并根据学到的经验教训重新适当地进行编码。
而曳光代码处理的是不同的问题。是对应用如何结合成一个整体、实际交互或整个架构骨架的简易实现版。之后的系统会继续按照第一次的曳光代码完成时的方式工作。
**区别**，原型制作生成用过就扔的代码。曳光代码简约却完整，是构成最终系统骨架的一部分。原型制作相当于曳光弹发射前的侦察和情报收集工作。
### 原型与便笺
原型可用于试验具体的想法，而对于软件也一样，可用原型来分析和揭示风险，并降低错误的代价，提供修正机会。
原型的设计目的就是回答一些问题，因此并不局限于以代码为基础。实现的过程可以忽略此刻来说不重要的细节
如果发现不能放弃细节，则需要考虑是否应转而使用曳光弹开发方式
#### 应制作原型的事物
* 任何带有风险的事物。
* 没有试过的事物
* 对于最终系统极端关键的事物
* 任何未被证明的、实验性的、或有疑问的事物
* 任何觉得不舒服的事物。
如架构、已有系统的新功能、外部数据的结构或内容、性能问题、用户界面设计第三方工具或组件等。
原型制作是一种学习经验，价值在于学到的经验教训，不在于代码。
构建原型时可以忽略**正确性**、**完整性**、**健壮性**、**风格**
#### 制作架构原型
制作架构原型，可以用便笺或索引卡片、在白板上制作，探求系统是怎样结合成一个整体，并延迟考虑细节。
可以探求：
* 主要组件的责任是否得到了良好、恰当的定义
* 主要组件间的协作是否得到良好的定义
* 耦合是否已最小化
* 能否确定重复的潜在来源
* 接口定义和各项约束是否可接受
* 每个模块在执行过程中是否能访问到其所需的数据？是否能在需要时进行访问。
适当使用原型可以在开发周期的早期确定和改正潜在的问题点，避免后期改正带来的昂贵的代价。
### 领域语言
> 语言的界限就是一个人的世界的界限。一一维特根斯坦  
我们应总是设法使用应用领域的语汇来编写代码，或者发明一种相应领域的语言来进行编程。
当用户对应用做了良好限定的陈述，可是通过发明一种为应用领域进行适当裁剪的小型语言，来确切表达需求。这种语言无须可执行。只是用于捕捉用户需求的一种方式、一种规范。而后续则可以通过实现该语言来使规范变成可执行代码。
**靠近问题领域编程**，通过靠近问题领域编程可以在更高的抽象层面上编码，获得专心解决领域问题的自由度。同时可以获得更具体的相关领域的错误。
#### 实现小型语言
诀窍是首先使用像**BNF**这样的表示法定义语法。规定了文法后，就可容易地将其转换为解析器生成器的输入语法。而另一种途径是可以通过扩展已有的语言来实现小型语言。
#### 数据语言与命令语言
可以通过两种不同的方式使用实现的语言
1. 数据语言产生某种形式的数据给应用使用。这些类型的语言常用于表示配置信息。
2. 命令语言更进一步，语言被实际执行，可包含语句，控制结构等。
#### 独立语言与嵌入式语言
要发挥作用，小型语言无须由应用直接使用。许多时候，可以使用规范语言创建各种由程序自身编译、读入或用于其他用途的制品。
把高级语言直接嵌入应用是一种常见做法。这样它们可在代码运行时执行。通过改变应用读取的脚本改变应用的行为，而不用编译。显著简化动态的应用领域中的维护工作。
#### 易于开发还是易于维护
权衡要素是**可扩展性与维护**。更具表现力的语言更难编写，简单的语言容易解析却缺乏表现力，更难理解。
### 估算
通过学习估算，并将此技能发展到对事物的数量级有直觉的程度就能展现出一种魔法般的能力，确定它们的可行性。
#### 多准确才足够准确
某种程度上，所有的解答都是估算。只是准确度不同，因此当需要进行估算时第一个要问自己的问题是：解答问题的语境是什么。
#### 估算来自哪里
所有的估算都以问题的模型为基础。但有一个基本估算诀窍是：找做过这些事的老司机来借鉴经验。
##### 理解提问内容
任何估算练习的第一步都是建立对提问内容的理解。把握精确度与问题域的范围。
##### 建立系统的模型
根据对所提问题的理解，建立粗略、就绪的思维模型骨架
##### 把模型分解为组件
一旦拥有了模型，就可以把它分解为组件，而我们需要找出描述组件怎样支互的数学规则。且在典型情况下，每个组件都有一些参数，会对整个模型产生影响。这个阶段需要确定每个参数。
##### 给每个参数指定值
一旦分解出各个参数，就可以逐一给每个参数赋值。这里有可能会引入一些错误。诀窍是找出哪些参数对结果的影响最大，并致力于让它们大致正确。
##### 计算答案
多次计算改变关键参数的值，直到找出真正主导模型的那些参数。根据参数表述答案。如果得到很奇怪的答案，而计算过程又是正确的，那可能表示对问题或模型的理解是错的。这是宝贵的信息。
##### 追踪自己的估算能力
记录估算，从而让自己看到自己接近正确答案的程度是一个很好的主意。如果总体估算涉及到子估算，则同样也要追踪这些子估算
若估算不正确的话，则需要找出为何会造成这种情况。改善自己的估算能力。
#### 估算项目进度
面对相当大的应用开发的各种复杂问题与反复无常的情况时，普通估算规则可能会失效。而此时为项目确定进度表的唯一途径常常是在相同的项目上获取经验。
而对于增量开发可重复下面的步骤：
* 检查需求
* 分析风险
* 设计、实现、集成
* 向用户确认
在被要求进行估算时放慢估算的速度并使用上述技巧，可以得到更好的结果。