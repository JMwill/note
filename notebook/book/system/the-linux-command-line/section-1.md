# 第一部分

## 第四章

Linux 中文件名并不反映文件本身，因此一般可以通过使用 `file` 命令来获得文件相关的详细信息：`file filename`。Linux 中一切皆文件

`less` 命令查看文本文件内容，在确定了文件类型后可以使用这个命令来阅读需要的内容

## 第五章

通配符：

- \* 匹配任意多个字符（0, 1, ...)
- ? 匹配任意一个字符
- [characters] 匹配任意一个属于字符集中的字符
- [!characters] 匹配任意一个不属于字符集中的字符
- [[:class:]] 匹配指定 **字符类** 中的字符

字符类：

- [:alnum:] 匹配任意一个字母或数字
- [:alpha:] 匹配任意一个字母
- [:digit:] 匹配任意一个数字
- [:lower:] 匹配任意一个小写字母
- [:upper:] 匹配任意一个大写字母

**当描述一个命令时，如果命令的参数后面带有`...`表明参数可以重复**

## 第六章

### man 手册的组织形式：

1. 用户命令
2. 程序接口内核系统调用
3. C 库函数程序接口
4. 特殊文件，如：设备结点和驱动程序
5. 文件格式
6. 游戏娱乐，如：屏幕保护程序
7. 其他
8. 系统管理员命令

命令：`man 5 passwd` 就会显示文件 `/etc/passwd` 的文件格式说明手册

`apropos` 命令可以基于某个关键字匹配进行命令的搜索，输出结果的第一个字段代表手册页的名字，第二个字段表示章节，这个命令跟 `man -k` 效果一样。其中 `apropos .` 或者 `man -k .` 可以列出所有的命令

### info 命令

- ? 显示命令帮助
- PgUp 或者 Backspace 显示上一页
- PgDn 或者 Space 显示下一页
- n 显示下一个节点
- p 显示上一个节点
- u 显示当前节点的父节点
- Enter 激活光标下的超链
- q 退出

## 第七章

`>` 是一个重定向符，当输入为空时可以清空文件的内容：`> output.txt` 前面的操作可以清空一个文件的内容，因为输入源为空。

`>` 为覆盖写入，`>>` 为追加写入

标准错误输出重定向通过 `2>` 实现，如：`ls -l /not/exist/folder 2> error.txt`，可以将错误信息收集到 error.txt 中。

### 收集标准输出以及标准错误

同时重定向标准输出和标准错误：`ls -l /not/exist/folder > output.txt 2>&1`，其中 &1 表示标准输出，`2>&1` 也就是说将标准错误重定向到标准输出，而 **标准错误重定向** 必须出现在 **标准输出重定向** 之后。因为只有先完成了标准输出重定向到文件，再进行标准错误重定向到标准输出，这时的错误才是输出到文件的，否则如果先进行标准错误重定向到标准输出，那么实际上错误是输出到屏幕（标准输出默认的输出地方）

而 bash 等提供了更简便的方法来执行上面的工作：`ls -l /not/exist/folder &> error.txt`。

在处理不需要的输出时将其重定向到 `/dev/null` 就可以隐藏输出

## 第八章

算术表达式展开：`$((1 + 1))`，括号内表达式有没有空格不影响，支持正常的运算符号，还有：`%`（取余），`**`（乘方），除法结果会被取整。

花括号展开：`{1,2,3}`，展开模式可以是一个含有开头、结尾的区间，花括号还可以嵌套：

- 逗号分隔的字符串列表：`{abc,cde,fgh}`
- 整数区间：`{1..10}`
- 单个字符区间：`{A..Z}`
- 嵌套：`echo a{A{1..10},B{1..10}}b`

命令替换，把一个命令的输出作为一个展开模式来使用：`echo $(ls)`，如：`file $(ls /usr/bin/* | grep zip)`，`$()` 可以用 `` `` 替换

**双引号**：双引号内包裹的字符串 shell 中的特殊字符都失去其特殊含义，成为一般字符，而 `$` `\` `` ` `` 除外。

**单引号**：禁止所有的展开，全部特殊字符都成为一般字符

## 第十章 系统安全相关部分

需要接触了解的命令：

- `id` 显示用户身份号
- `chmod` 更改文件模式
- `umask` 设置默认文件权限
- `su` 以另一个用户身份来运行 shell
- `sudo` 以另一个用户身份来运行命令
- `chown` 更改文件所有者
- `chgrp` 更改文件组所有权
- `passwd` 更改用户密码

### chmod

chmod 可以通过 **八进制数字表示法** 或者 **符号表示法** 来进行权限设置

#### 符号表示法

对象：

- `u` 文件或目录的所有者（User）
- `g` 用户组（Group）
- `o` 其他所有人（Other）
- `a` `u` `g` `o` 三者的联合

操作符：

- `+` 增加权限
- `-` 删除权限
- `=` 除了增加后接的权限外，将其他权限清除掉

权限：`r`、`w`、`x`

使用方式是：`(对象)(操作符)(权限)`

### umask

| file mode | --- rw- rw- rw- |
| --------- | --------------- |
| Mask      | 000 000 010 010 |
| Result    | --- rw- r-- r-- |

umask 的作用就是设置新建的文件/文件夹的权限，为 1 的位置代表**不赋予**对应的权限，最前面的三个 0 是用来设置特殊的权限的。

其中八进制的 4000 设置 `setuid 位` 应用到一个可执行文件时，这个文件运行时就是以程序所有者的 ID 来运行的，而不是运行程序者的 ID 来运行，一般这种设置会用在超级用户拥有的程序上，普通用户运行这种程序时，这个程序还可以访问到普通用户禁止访问的目录/文件。

八进制 2000 则是用于设置 `setgid 位` 也是一样的将用户组 ID 更改为文件所有者的组 ID，目录中新建的文件就具有目录所属用户组的所有权，而不是文件所有者所属用户组的所有权。对于共项目录来说很有用

八进制 1000 设置 `sticky 位` Linux 会忽略文件的 sticky 位，但是如果一个目录设置了这个位，就可以阻止用户删除或者重命名，只有用户是目录的所有者，文件所有者或者超级用户。经常用来控制共享目录访问如：`/tmp`

用 chmod 来修改的话也可以：

- `chmod u+s file` 对应 4000， 例子：-rwsr-xr-x
- `chmod g+s dir` 对应 2000
- `chmod +t dir` 对应 1000

### chown

参数：

- `chown bob` 将文件所有者修改为用户 bob
- `chown bob:users` 将文件所有者修改为用户 bob，文件用户组修改为用户组 users
- `:admins` 文件用户组修改为 admins，文件所有者不变
- `bob:` 文件所有者修改为用户 bob，文件用户组改为用户 bob **登录系统时**所属用户组

## 第十一章 进程

- `ps` 报告当前进程快照
- `top` 显示任务
- `jobs` 列出活跃任务
- `bg` 将任务放到后台执行
- `fg` 将任务放到前台执行
- `kill` 给进行发信号
- `killall` 杀死指定名字的进程
- `shutdown` 关机/重启系统

通过在执行的命令后面带上 `&` 符号可以将执行的命令放到后台运行，这时的运行的程序对任何键盘的输入都免疫。需要通过 `fg` 命令将程序调回前台。 `fg %1` 当具有多个后台任务时，`%1` 就代表需要放回前台的任务的索引。这个索引可以通过使用 `jobs` 命令获得。

`ctrl-c` 用于终止程序的运行，但如果仅仅想要 **停止** 程序的运行，那可以通过 `ctrl-z` 来停止程序，这时停止了的程序可以通过 `fg` 命令来调回前台，或者 `bg` 命令来调回后台。使用方式一样是需要用到 `%` 加 **索引**。

### kill

`kill` 命令用于发送信号给运行的程序，一般默认的信号为：15，表示终止，但是是在程序依然“活着”（能处理信号）的情况下有用：`kill 123` 相当于 `kill -15 123`k

其他信号：

- 1(HUP) 挂起，表示控制程序的终端机已经“挂断”
- 2(INT) 中断，相当于 `ctrl-c`
- 3(QUIT) 退出 k
- 9(KILL) 杀死，直接杀死程序，信号发送给内核，因此程序无法在停止前执行清理等过程
- 15(TERM) 终止，默认信号
- 18(CONT) 继续，在停止信号后使用才有效，恢复程序运行
- 19(STOP) 停止，停止程序运行，由内核接收，因此不会被忽略
- 20(TSTP) 终端停止，相当于 `ctrl-z` 由目标进程接收，可能被忽略
- 28(WINCH) 窗口大小改变，像 top、less 等程序会响应这个信号

信号可以通过数字，也可以通过名称或者加上 `SIG` 后的名称来表示：`kill -INT 123` 或者 `kill -SIGINT 123`

使用 `killall` 命令则可以对多个进程发送信号
