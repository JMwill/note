# 巜程序员修练之道》

## 注重实效的项目

项目启动后，需要从个体的哲学和编码问题转向讨论更大的、项目级的问题

- 一旦项目参与人员超过一个，就需要建立一些基本原则并相应地分派任务。
* 使项目级活动保持一致和可靠的一个最重要的因素是使各种工作流程自动化。
* 在编码的同时进行测试。
* 撰写文档，并通过工具减少撰写的麻烦以及工作。
* 成功取决于旁观者（项目出资人）的眼睛，而成功的感觉很重要

### 注重实效的团队

称为注重实效的个体有好处，而个体在注重实效的团队中工作，好处会成倍增长。

#### 不要留破窗户

质量是一个团队问题。团队作为一个整体，不应该容忍破窗户——小的，无人修正的不完美。团队必须为产品的质量负责，并支持了解“不要留破窗户”哲学的开发者，并鼓励还不了解这种哲学的人。

#### 煮青蛙

即使是目的最明确的团队对项目中的重大改动也可能会健忘，因此需要主动地监视环境的变化。可以通过指派人来持续地检查范围的扩大、时间标度的缩减、新增特性、新环境——任何不在最初约定中的东西。对新需求进行持续的度量。要注意到变化正在发生。

#### 交流

杰出的团队有着截然不同的个性，且制作的文档新鲜、准确、一致。对外部用同一个声音说话。“创立品牌”可以帮助团队作为整体与外界交流。通过创立项目名称，设计标识，可以给团队一个用于建设的身份标识，并给世界以某种难忘的、可以与工作相关联的东西。

#### 不要重复你自己

可以通过指定项目资料管理员，负责协调文档和代码仓库。让团队成员查找资料时可以先找这个人，并由管理员通过阅读正在处理的资料，发现迫近的重复。而当项目过于巨大时，可以指定多人负责各个方面。并要对问题和解答进行存档。

#### 正交性

**围绕功能，而不是工作职务进行组织**

按照功能划分团队，将人划分为小团队，并负责最终系统的特定方面的功能。让团队内部自行组织。并按照他们约定的承诺对项目中的其他团队负有责任。承诺的确切内容随项目而变化，团队间的人员分配也是如此。

内聚的，自足的团队和模块化代码类似，如果两个子团队在做同一个程序模块或类，那就表明出现了问题。

按功能组织，使用用于组织代码的相同技术，如合约（按合约设计）、解耦、正交性来组织各种资源，有助于使团队作为整体与变化的各种效应隔离开来。这种分组方式能够极大减少各个开发者工作间的相互影响、缩短时间标度、提高质量、并减少缺陷数目。

这种途径的实现需要有负责的开发者、以及强有力的项目管理。技术主管设定开发哲学和风格，指派团队责任，仲裁成员间的争论，不断关注大图景，并设法找出团队之间的不必要的、可能降低总体正交性的交叉。行政主管（或项目经理）调度各团队所需的各种资源，监视并报告进展情况，根据商业需要帮助确定各种优先级。并充当团队的大使与外界交流。

#### 自动化

确保一致和准确的一种很好的方式是使团队做的每件事情自动化。

自动化是每个项目团队的必要组成部分。为了确保事情得以自动化，指定人员进行工具构建，构造和部署项目自动化工具。

### 无处不在的自动化

构建和发布流程、书面的代码复查工作、或是其他任何在项目中反复出现的任务都必须要是自动的。人工流程无法确保项目的一致性和可重复性。

#### 一切都要自动化

**不要使用手工流程**

shell脚本或批处理文件可以以相同的次序、反复执行同样的命令，并置于版本管理之下。或者是使用自动化工具cron，自动安排备份、夜间构建、网站维护或其他可以无人照管完成的事情。

#### 项目编译

使用makefile编译项目，由于它是脚本化、自动化的流程。可以增加挂钩，让其生成代码，自动运行回归测试等。使得一条命令就可以完成签出、构建、测试和发布。

##### 生成代码

生成代码，以根据公共来源派生知识，减少重复的危害。并且还可以用同样的一组规则，根据其他形式的文件，自动生成源代码、头文件、或是文档等。

##### 回归测试

使用makefile运行回归测试，或是针对单个模块，或是针对整个子系统。只要一条命令就可以完成所需的测试。

#### 构建自动化

典型的项目构建包括：

1. 从仓库签出源码
2. 从头开始构建项目，典型情况下是从顶层makefile开始。
3. 创建可分发映像。过程中可能需要确定文件所有权和权限，并严格按照发布时所需的格式生成例子、文档、README文件等。
4. 运行规定的测试。

**最终构建**，此时如果产品的编译方式与先前的版本不同，需要针对这个版本再次进行所有测试。

#### 自动化管理

因为人的记忆的不可靠，我们需要脚本来让基于源码和文档的内容，自动完成各种流程，维持自动、无人照管、内容驱动的工作流。

**网站生成**. 使用网站来进行项目交流。那么就需要保证内容足够的新，并且减少维护的时间。制作自动构建，将代码、需求分析、设计文档中提取的文档以及任何图片、图表或图形定期发布到网站上。Web内容应该根据仓库中的信息自动生成，并无需人的干预就发布。

**批准流程**. 有些项目具有各种必须遵循的管理工作流。如安排代码或设计复查，批准等。可以使用自动化来减轻书面工作负担。

使用系统自带工具或者高级脚本语言，来快速开发自制的工具、网页生成器、代码生成器、测试装备等。利用计算机去做重复平庸的事情。

### 无情的测试

**早测试，常测试，自动测试**

在编写产品代码的同时（甚至更早）编写测试代码，bug发现得越早，进行修补的成本就会越低。

测试通过会带来自行，而且**全部测试通过了，编码才算完成**

项目测试的三个主要方面是：测试什么、怎样测试、何时测试。

#### 测试什么

测试的主要类型有：

- 单元测试
- 集成测试
- 验证和校验
- 资源耗尽、错误及恢复
- 性能测试
- 可用性测试

还有一些特殊项目会需要其他类型的测试，这里并没有加上。

**单元测试**。单元测试是对某个模块进行演练的代码。上述的其他形式测试的基础。所有模块必须通过自己的单元测试。

**集成测试**。集成测试说明组成项目的主要子系统能工作，并能很好地协同。在适当的地方有好的合约，并进行良好的测试，可以轻松地检测到任何集成问题。而集成测试实际上只是单元测试的一种拓展。

**验证和校验**。系统是否满足功能需求也需要进行测试。要注意用户的访问模式，以及这些模式与开发者所用的测试数据的不同。

**资源耗尽、错误及恢复**。现在，系统在理想情况下应该会正确运行，但是在现实世界中，程序没有无限的资源，因此需要对环境的限制进行检测。并且当系统失败时，得体地失败，尽可能地设法保存其状态、防止工作内容的丢失。

**性能测试**。性能测试、压力测试或负载测试可能会是项目的一个重要方面。软件应该能够满足现实世界的条件下的性能需求——连接数、每秒事务数，伸缩能力等。有时需要专门的测试硬件或软件模拟负现实情况下的负载。

**可用性测试**。可用性测试由真正的用户在真实的环境条件下进行的。根据人的因素考察可用性。

#### 怎样测试

怎样测试的注意力在：

- 回归测试
- 测试数据
- 演练GUI系统
- 对测试进行测试
- 彻底测试

**回归测试**。回归测试把当前测试的输出与先前的（或已知的）值进行对比。这样做可以确定当前的修正没有对以前的可工作代码进行破坏。

**测试数据**。数据只有两种：现实世界的数据和合成的数据。两种数据对于测试而言都需要，不同性质的数据能够揭示出软件中不同的bug。

现实世界的数据来自某种实际来源。它代表典型的用户数据，最有可能揭示出需求分析中的缺陷和误解。

合成数据是人工生成的数据——或许受制于特定的统计约束。出于以下原因，都有可能需要使用合成数据：

- 需要的数据量超过了任何现实世界的样本所能提供的数量。
- 需要能强调边界条件的数据。
- 需要能展示特定统计属性的数据

**演练GUI系统**。测试GUI密集型系统常需要专门的测试工具。可能基于简单的事件捕捉/重放模型，或专门的脚本驱动GUI等。

编写的解除了耦合的代码能够单独对应用逻辑进行测试而无需使用GUI，一旦应用逻辑得到验证，就能容易地定位问题出现在使用GUI的情况下。

**对测试进行测试**。在编写测试用于检测特定的bug时，要故意引发bug，并确定测试会发出提示。确保测试在bug真的出现时能够捕捉到。

通过“蓄意破坏“测试编写的测试

**彻底测试**。覆盖分析工具会在测试过程中监视代码，追踪哪些代码执行过，能够以此从总体上了解测试的全面程度，但是真正重要的是测试程序的状态覆盖，而不是代码覆盖。

#### 何时进行测试

一旦产品代码存在，就需要进行测试。而且大多数测试都应该自动完成，并尽可能频繁地进行测试。

如果有bug在现有的测试网中漏了，需要增加新的测试确保在下一次抓住它，**一个bug只抓一次**

### 全都是写

**把英语当作又一种编程语言**

为项目制作的文档基本有两种：内部文档和外部文档。内部文档包括源码注释、设计与测试文档等。外部文档是发布到外界的任何东西。但是所有的文档都是代码的反映。如果有歧义，代码才是最要紧的，无论好坏。

**把文档建在里面，不要栓在外面**

#### 代码中的注释

根据源码中的注释和声明产生格式化文档必须确保在代码中确实有注释。且准确并不应该过多。注释应该讨论为何要做某事、代码的目的和目标。至于是怎样完成的则由代码自身来解释无需注释。

注释源码可以把项目中难以描述、容易忘记，又不能记载在别的任何地方的东西记载下来：工程上的权衡、重要数据与类型声明的注释、每个类和每个方法加的简要头注释、描述函数用法和任何不明了的事情。

不应该出现在源码注释中的一些内容：

- 文件中的代码导出的函数的列表
- 修订历史
- 该文件使用的其他文件的列表
- 文件名

#### 可执行文档

如果文档是作为带有标记命令的纯文本存储的，可以用工具如Perl来自动提取schema，并重新对其进行格式化。这样可以保证规范、schema、代码全是一致的。这样可以将每次更改必需的工作量减到最低，而且可以自动更新所更改的各种视图。

#### 打印还是编排

设法把文档制作成能够在Web上在线发布的形式，用超链接整合在一起。使文档的这一视图保持最新，比分发打印副本更容易。

文档和代码是同一底层模型的不同视图，但视图是唯一应该不同的东西。对待文档要像对待代码一样用心，而不要被排除在项目主要工作流之外。

### 极大的期望

现实中，项目的成功由他在多大程度上满足了用户的期望来衡量。不符合用户预期的项目注定是失败的，不管交付的产品在绝对意义上有多好。

**温和地超出用户的期望**

做到上面一条需要做一些工作

#### 交流期望

不要忽略用户一开始带着对所需要的东西的想象。即使想象不完整、不一致或技术上做不到都不能简单地忽视它。随着对用户需要的理解的发展，正确评估后，与用户交流并使他们正确理解将要交付的产品。开发的整个过程中都需要进行这样的交流。且决不要忘记应用要解决的商业问题。

”曳光弹“和”原型与便笺”是促进这一过程最为重要的技术。两者都让团队构造用户能看见的东西。都是与用户交流你对他们的需求的理解的理想途径。都能让你和用户习惯于交流。

#### 额外的一英里

给用户的东西要比他们期望的多一些。这样将在商誉上带来回报。增加的新特性最好是相对表面的，并且实际上不会因为特性肿胀而给系统带来过度的负担。同时不要因为增加新特性而破坏系统。

### 傲慢与偏见

**在作品上签名**

匿名（尤其在大型项目中）可能会繁殖出邋遢、错误、懒惰和糟糕的代码。因此签名应该被视为质量的保证。当在代码上看到名字时，应该期望它是可靠的，用心编写的、测试过的和有文档的。
